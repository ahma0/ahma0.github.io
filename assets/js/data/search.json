[ { "title": "Android Studio - \"trying to draw too large bitmap\" 오류가 발생할때.", "url": "/posts/trying-to-draw-too-large-bitmap/", "categories": "Study, Android", "tags": "Android, AndroidStudio, Study, JAVA, ERROR", "date": "2023-01-05 21:32:00 +0900", "snippet": " [에러 메시지] trying to draw too large bitmap그냥 카카오 로그인 사진 하나 추가했을 뿐인데 해당 오류가 나타났다.해결방법하드웨어의 가속 해제AndroidManifest.xml 파일에 application 내에 해당 코드를 추가한다.android:hardwareAccelerated=\"false\"파일 분류하드웨어 가속을 사용...", "content": " [에러 메시지] trying to draw too large bitmap그냥 카카오 로그인 사진 하나 추가했을 뿐인데 해당 오류가 나타났다.해결방법하드웨어의 가속 해제AndroidManifest.xml 파일에 application 내에 해당 코드를 추가한다.android:hardwareAccelerated=\"false\"파일 분류하드웨어 가속을 사용하여야 하는 경우 이미지 파일을 옮기는 것으로 해당 오류를 해결할 수 있다. 해당 오류는 이미지 파일이 너무 크기 때문에 발생하는 오류이기에 높은 해상도 파일로 옮겨준다.drawable 우클릭하여 Open In을 클릭 Explorer로 들어간다.drawable-xxxhdpi를 생성하여 문제가 되는 이미지 파일을 옮겨준다." }, { "title": "Spring 3.0.0 이상 프로젝트 생성 시 에러", "url": "/posts/Spring3-jdk17/", "categories": "Study, Spring", "tags": "Spring, Springoot, Study, JAVA, ERROR", "date": "2023-01-05 19:00:00 +0900", "snippet": " [에러 메시지] Could not resolve org.springframework.boot:spring-boot-gradle-plugin:3.0.1.이 에러는 스프링 3.0.0 이상의 프로젝트를 생성 시 나는 것 같다. 이유를 찾아보니 jdk 11을 선택해서 에러가 나는 것 같은데.. 이제 Spring3부터는 jdk 11을 지원하지 않는 것 같다...", "content": " [에러 메시지] Could not resolve org.springframework.boot:spring-boot-gradle-plugin:3.0.1.이 에러는 스프링 3.0.0 이상의 프로젝트를 생성 시 나는 것 같다. 이유를 찾아보니 jdk 11을 선택해서 에러가 나는 것 같은데.. 이제 Spring3부터는 jdk 11을 지원하지 않는 것 같다.따라서 jdk 17로 버전을 변경해주면 이 에러를 해결할 수 있다.해결방법생성하기 이전이라면 jdk를 17로 선택하여 생성하면 된다.하지만 생성한 이후라면프로젝트에서 File -&gt; Project Structure에 들어가 jdk를 17로 변경해준다.jdk가 깔려있지 않은 경우add SDK -&gt; download jdk를 들어가 원하는 jdk를 다운받는다.나는 Amazon Corretto를 선택하였다.JDK 17 종류 관련 내용을 가져온 출처이다. 해당 내용을 자세히 알고싶다면 클릭Oracle JDK Oracle에서 제공하는 JDK. 구독을 통해 유료 라이센스를 구매할 수 있다.OpenJDK 유명한 무료 JDK. OpenJDK를 직접 사용하는것 보다는, OpenJDK 기반으로 빌드된 JDK 사용을 추천한다.Azul Zulu 인지도가 높은 JDK 중 하나 Mac 등에서 사용할 수 있는 바이너리를 제공한다.Amazon Corretto AWS에서 제공하는 JDK. AWS에서 쉽게 사용 가능하며, AWS 환경이 아니더라도 사용할 수 있다. Amazon에서 업데이트를 지원.Eclipse Temurin Eclipse에서 제공하는 JDK. Eclipse를 사용하는 경우 Temurin를 설치하길 추천한다." }, { "title": "Git subtree 정리", "url": "/posts/subtree/", "categories": "Study, Git", "tags": "Git, Github, Study, Subtree", "date": "2022-11-13 13:26:00 +0900", "snippet": " 참고사이트subtree 너무 헷갈리고 어려워서 따로 정리하기로 결심했다!모르는게 많아서 나중에 더 추가될 수도 있다.내가 A레포를 생성하여 B레포에 폴더로 넣고싶다고 가정한다.A 레포를 B 레포에 넣는다면 A 레포가 child, B 레포가 parent.포함하는게 parent, 포함되어지는게 child이다.Info Reposito...", "content": " 참고사이트subtree 너무 헷갈리고 어려워서 따로 정리하기로 결심했다!모르는게 많아서 나중에 더 추가될 수도 있다.내가 A레포를 생성하여 B레포에 폴더로 넣고싶다고 가정한다.A 레포를 B 레포에 넣는다면 A 레포가 child, B 레포가 parent.포함하는게 parent, 포함되어지는게 child이다.Info Repository branch     Parent main   Child master subtree 생성방법먼저 Parent 레포를 클론하여 로컬 레포지토리를 만든 후 로컬 레포에서 git bash를 열어준다.$ git subtree add --prefix=&lt;폴더 이름&gt; &lt;child레포의 깃 주소&gt; &lt;child레포의 브랜치명&gt;폴더이름 : Parent 레포에 들어갈 Child 레포 폴더의 이름예를 들어, Parent 레포의 이름을 study, Child 레포 이름을 BFS라고 해보자. 브랜치 명은 위의 인포 표와 동일하다고 가정한다. 위의 명령어를 사용하여 Study 레포에 week1이라는 파일명으로 BFS 레포를 저장하고 싶을 때, 명령어는 다음과 같다.$ git subtree add --prefix=week1 &lt;BFS 레포의 깃 주소&gt; master그 후 다음 명령어를 작성해주고 깃허브 Parent 레포지토리에 들어가면 week1으로 잘 저장되어 있다.$ git push origin main+) remote 설정하기나는 이제부터 Child레포의 깃주소를 caddress로 지칭하겠다. 계속 깃 주소를 복붙하지 않기 위해 remote 해주자.$ git remote add caddress &lt;Child 레포의 깃주소&gt;Child 레포에서 Parent 레포로 push$ git subtree pull --prefix=&lt;폴더명&gt; caddress master $ git add .$ git commit -m \"커밋 제목\" -m \"커밋 내용\"$ git push아마 아까 예시를 이용한다면 다음과 같을 것이다.$ git subtree pull --prefix=week1 caddress master $ git add .$ git commit -m \"커밋 제목\" -m \"커밋 내용\"$ git push" }, { "title": "Spring AnnotationException - Illegal attempt to map a non collection as a @OneToMany, @ManyToMany or @CollectionOfElements", "url": "/posts/AnnotationException/", "categories": "Study, JPA", "tags": "Spring, Springoot, Study, JPA, JAVA, ERROR", "date": "2022-11-09 17:49:00 +0900", "snippet": " [에러 메시지] AnnotationException: Illegal attempt to map a non collection as a @OneToMany, @ManyToMany or @CollectionOfElements해결 방법 에러나는 코드@OneToMany(fetch = FetchType.LAZY) @JoinColumn(name = \"...", "content": " [에러 메시지] AnnotationException: Illegal attempt to map a non collection as a @OneToMany, @ManyToMany or @CollectionOfElements해결 방법 에러나는 코드@OneToMany(fetch = FetchType.LAZY) @JoinColumn(name = \"userId\") private UserEntity userId; UserEntity를 List로 고치기@OneToMany(fetch = FetchType.LAZY) @JoinColumn(name = \"userId\") private List&lt;UserEntity&gt; userId;" }, { "title": "Spring 중복키 설정", "url": "/posts/Duplication-Key/", "categories": "Study, JPA", "tags": "Spring, Springoot, Study, JPA, JAVA, ERROR", "date": "2022-11-09 16:07:00 +0900", "snippet": "JPA 엔티티에 중복키를 선언하려하니 duplicate 오류가 나서 방법을 찾아보았다.오류가 나는 코드 - entity/music/MusicMoodEntity.java@Data@Builder@AllArgsConstructor@Entity@Table(name = \"Music-Mood\")@NoArgsConstructor(access = AccessLeve...", "content": "JPA 엔티티에 중복키를 선언하려하니 duplicate 오류가 나서 방법을 찾아보았다.오류가 나는 코드 - entity/music/MusicMoodEntity.java@Data@Builder@AllArgsConstructor@Entity@Table(name = \"Music-Mood\")@NoArgsConstructor(access = AccessLevel.PROTECTED)public class MusicMoodEntity { @Id private String musicId; @Id private int moodNum;}아이디 두 개를 저 방식으로 설정하면 애노테이션이 겹쳐 duplication 에러가 나는 모양이다.이 코드를 아래와 같이 두 개의 파일로 나눠야한다.아이디 선언 entity/id/MusicMoodId.jaca@Data@Embeddablepublic class MusicMoodId implements Serializable { @Column(name = \"musicId\") private String musicId; @Column(name=\"moodId\") private int moodNum;}중복키 사용 - entity/music/MusicMoodEntity.java@Data@Builder@AllArgsConstructor@Entity@Table(name = \"Music-Mood\")@NoArgsConstructor(access = AccessLevel.PROTECTED)public class MusicMoodEntity { @EmbeddedId private MusicMoodId musicMoodId;}" }, { "title": "Spring 입문 5 - 회원 관리 예제(웹 MVC 개발)", "url": "/posts/Spring-Study-Basic-5/", "categories": "Study, Spring", "tags": "Spring, Springoot, Study, Inflearn", "date": "2022-07-31 14:13:00 +0900", "snippet": " 인프런 김영한 님 스프링 입문 강의를 들은 후 공부한 내용입니다.홈 화면 추가홈 컨트롤러 추가package hello.hellospring.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping...", "content": " 인프런 김영한 님 스프링 입문 강의를 들은 후 공부한 내용입니다.홈 화면 추가홈 컨트롤러 추가package hello.hellospring.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;@Controllerpublic class HomeController { @GetMapping(\"/\") public String home() { return \"home\"; }}회원 관리용 홈resources/templates/home.html&lt;!DOCTYPE html&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;h1&gt;Hello Spring&lt;/h1&gt; &lt;p&gt;회원 기능&lt;/p&gt; &lt;p&gt; &lt;a href=\"/members/new\"&gt;회원가입&lt;/a&gt; &lt;a href=\"/members\"&gt;회원목록&lt;/a&gt; &lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 참고: 컨트롤러가 정적 파일보다 우선순위가 높다.회원 웹 기능 - 등록회원 등록 폼 개발회원 등록 폼 컨트롤러hellospring/controller/MemberForm.javapackage hello.hellospring.controller;public class MemberForm { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; }}hellospring/controller/MemberController.javapackage hello.hellospring.controller;import hello.hellospring.domain.Member;import hello.hellospring.service.MemberService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PostMapping;import java.util.List;@Controllerpublic class MemberController { private final MemberService memberService; @Autowired public MemberController(MemberService memberService) { this.memberService = memberService; } @GetMapping(\"/members/new\") public String createForm() { return \"members/createMemberForm\"; } @PostMapping(\"/members/new\") public String cteate(MemberForm form) { Member member = new Member(); member.setName(form.getName()); memberService.join(member); return \"redirect:/\"; }}회원 등록 폼 HTMLresources/templates/members/createMemberForm.html&lt;!DOCTYPE html&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;form action=\"/members/new\" method=\"post\"&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"name\"&gt;이름&lt;/label&gt; &lt;input type=\"text\" id=\"name\" name=\"name\" placeholder=\"이름을 입력하세요\"&gt; &lt;/div&gt; &lt;button type=\"submit\"&gt;등록&lt;/button&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;회원 웹 기능 - 조회회원 컨트롤러에서 조회 기능hellospring/controller/MemberController.java@GetMapping(\"/members\")public String list(Model model) { List&lt;Member&gt; members = memberService.findMembers(); model.addAttribute(\"members\", members); return \"members/memberList\";}회원 리스트 HTML&lt;!DOCTYPE html&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;#&lt;/th&gt; &lt;th&gt;이름&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr th:each=\"member : ${members}\"&gt; &lt;td th:text=\"${member.id}\"&gt;&lt;/td&gt; &lt;td th:text=\"${member.name}\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;" }, { "title": "Spring 입문 4 - 컴포넌트 스캔과 자동 의존관계 설정", "url": "/posts/Spring-Study-Basic-4/", "categories": "Study, Spring", "tags": "Spring, Springoot, Study, Inflearn", "date": "2022-07-30 12:52:00 +0900", "snippet": " 인프런 김영한 님 스프링 입문 강의를 들은 후 공부한 내용입니다.스프링 빈을 등록하고, 의존관계 설정하기회원 컨트롤러에 의존관계 추가package hello.hellospring.controller;import hello.hellospring.service.MemberService;import org.springframework.beans.fact...", "content": " 인프런 김영한 님 스프링 입문 강의를 들은 후 공부한 내용입니다.스프링 빈을 등록하고, 의존관계 설정하기회원 컨트롤러에 의존관계 추가package hello.hellospring.controller;import hello.hellospring.service.MemberService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;@Controllerpublic class MemberController { private final MemberService memberService; @Autowired public MemberController(MemberService memberService) { this.memberService = memberService; }} 생성자에 @Autowired가 있으면 스프링이 연관된 객체를 스프링 컨테이너에서 찾아서 넣어준다. 이렇게 객체 의존관계를 외부에서 넣어주는 것을 DI(Dependency Injection), 의존성 주입이라 한다. 이전 테스트에선 개발자가 직접 주입했고, 여기서는 @Autowired에 의해 스프링이 발생한다. @Controller가 로테이션 되어 있으면 스프링 컨테이너에 멤버 컨트롤러란 객체를 생성하여 관리함. 이것을 스프링 컨테이너에서 스프링 빈이 관리된다고 표현memberService가 스프링 빈으로 등록되어 있지 않다. 참고: helloController는 스프링이 제공하는 컨트롤러여서 스프링 빈으로 자동 등록된다. @Controller가 있으면 자동 등록됨.스프링 빈을 등록하는 2가지 방법 컴포넌트 스캔과 자동 의존관계 설정 자바 코드로 직접 스프링 빈 등록하기컴포넌트 스캔과 자동 의존관계 설정 @Conponent 애노테이션이 있으면 스프링 빈으로 자동 등록된다. @Controller 컨트롤러가 스프링 빈으로 자동 등록된 이유도 컴포넌트 스캔 때문이다. @Component를 포함하는 다음 애노테이션도 스프링 빈으로 자동 등록된다. @Controller @Service @Repository 회원 서비스 스프링 빈 등록package hello.hellospring.service;import hello.hellospring.domain.Member;import hello.hellospring.repository.MemberRepository;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;import java.util.Optional;@Servicepublic class MemberService { private final MemberRepository memberRepository; @Autowired public MemberService(MemberRepository memberRepository) { this.memberRepository = memberRepository; }} 참고: 생성자에 @Autowired를 사용하면 객체 생성 시점에 스프링 컨테이너에서 해당 스프링 빈을 찾아서 주입한다. 생성자가 1개만 있으면 @Autowired는 생략할 수 있다.회원 리포지토리 스프링 빈 등록package hello.hellospring.repository;import hello.hellospring.domain.Member;import org.springframework.stereotype.Repository;import java.util.*;@Repositorypublic class MemoryMemberRepository implements MemberRepository{스프링 빈 등록 이미지 memberService와 memberRepository가 스프링 컨테이너에 스프링 빈으로 등록되었다. 참고: 스프링은 스프링 컨테이너에 스프링 빈을 등록할 때, 기본으로 싱글톤으로 등록한다(유일하게 하나만 등록해서 공유한다). 따라서 같은 스프링 빈이면 모두 같은 인스턴스다. 설정으로 싱글톤이 아니게 설정할 수 있지만, 특별한 경우를 제외하면 대부분 싱글톤을 사용한다.자바 코드로 직접 스프링 빈 등록하기 회원 서비스와 회원 리포지토리의 @Service, @Repository, @Autowired 애노테이션을 제거하고 진행한다.hello.hellospring/SpringConfig.javapackage hello.hellospring;import hello.hellospring.repository.MemberRepository;import hello.hellospring.repository.MemoryMemberRepository;import hello.hellospring.service.MemberService;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class SpringConfig { @Bean public MemberService memberService() { return new MemberService(memberRepository()); } @Bean public MemberRepository memberRepository() { return new MemoryMemberRepository(); }}여기서는 향후 메모리 리포지토리를 다른 리포지토리로 변경할 예정이므로, 컴포넌트 스캔 방식 대신에 자바 코드로 스프링 빈을 설정하겠다. 참고: XML로 설정하는 방식도 있지만 최근에는 잘 사용하지 않으므로 생략한다. 참고: DI에는 필드 주입, setter 주입, 생성자 주입 이렇게 3가지 방법이 있다. 의존관계가 실행중에 동적으로 변하는 경우는 없으므로 생성자 주입을 권장한다.필드 주입@Controllerpublic class MemberController { @Autowired private MemberService memberService; //필드주입}setter 주입@Controllerpublic class MemberController { //setter 주입 -&gt; memberService가 public으로 노출되어있음 private MemberService memberService; @Autowired public void setMemberService(MemberService memberService) { this.memberService = memberService; }}생성자 주입@Controllerpublic class MemberController { //생성자 주입 private final MemberService memberService; @Autowired public MemberController(MemberService memberService) { this.memberService = memberService; }} 참고: 실무에서는 주로 정형화된 컨트롤러, 서비스, 리포지토리 같은 코드는 컴포넌트 스캔을 사용한다. 그리고 정형화되지 않거나, 상황에 따라 구현 클래스를 변경해야 하면 설정을 통해 스프링 빈으로 등록한다. 주의: @Autowired를 통한 DI는 helloController, MemberService 등과 같이 스프링이 관리하는 객체에서만 동작한다. 스프링 빈으로 등록하지 않고 내가 직접 생성한 객체에서는 동작하지 않는다." }, { "title": "IntelliJ 단축키 (Windows / Linux)", "url": "/posts/IntelliJ-Keys-For-Window-Linux/", "categories": "Post, IntelliJ", "tags": "IntelliJ", "date": "2022-07-27 15:39:00 +0900", "snippet": "General : 일반적인 단축키     Alt + #[0-9] 각 단축키에 해당하는 도구창 열기 Ctrl + S 모두 저장 Ctrl + Shift + F12 편집기(Editor) 영역을 최대로 크기로 토글 ...", "content": "General : 일반적인 단축키     Alt + #[0-9] 각 단축키에 해당하는 도구창 열기 Ctrl + S 모두 저장 Ctrl + Shift + F12 편집기(Editor) 영역을 최대로 크기로 토글 Ctrl + Shift + I 현재 프로필 기준으로 현재 파일 검사 Ctrl + Alt + S 설정창(Settings) 열기 Ctrl + Alt + Shift + S 프로젝트 구조창(Project Structure) 열기 Double Shift 전체 검색창 열기 Debugging : 디버깅 관련 단축키     F8 현재 브레이크된 라인에서 다음 라인으로 이동 F7 현재 브레이크된 라인에서 실행하고 있는 메소드로 이동 Shift + F8 브레이크된 라인에서 호출한 곳으로 이동 Alt + F9 포커스 되어있는 라인으로 이동 Alt + F8 브레이크된 라인에서 사용 가능한 모든 코드를 실행 F9 다음 브레이크 포인트로 이동 Search / Replace : 검색 및 대체 관련 단축키       Double + Shift 전체 검색창 열기 (Alt + 방향키로 All, Class, File, Symbol, Actions 등 선택 가능)   Ctrl + Shift + F 문자열 검색창 열기   Ctrl + F 현재 파일에서 문자열 검색   F3 / Shift + F3 검색된 문자열로 이전/이후 이동   Ctrl + R 현재 파일에서 문자열 대체   Editing : 편집기(IDE) 관련 단축키     Ctrl + Space 기본 코드를 자동 완성 Ctrl + Shift + Space 소스코드를 분석해서 적합한 자동 완성 코드를 추천 Ctrl + Shift + Enter 문장 자동 완성(if문, for문 등) Ctrl + P 메서드의 파라미터 정보를 조회 Ctrl + Q 도큐먼트를 조회 Ctrl + O Override 가능한 메서드 목록을 확인하여 코드를 자동 생성 Ctrl + I Implement 가능한 메서드 목록을 확인하여 코드를 자동 생성 Ctrl + / 라인 단위로 주석 처리(//로 주석처리) Ctrl + Shift + / 블록 단위로 주석 처리(/* */로 주석처리) Ctrl + . 블록 접기/열기 Ctrl + W 커서 근처의 코드 선택 영역을 확대 Ctrl + Shift + W 커서 근처의 코드 선택 영역을 축소 Alt + Enter 추가되지 않은 Import 추가 Alt + Shift + Enter 가로/세로 편집모드로 변경 Ctrl + Alt + L 코드 정렬 Ctrl + Alt + O Import 정리(사용하지 않는 Import 삭제) Ctrl + Alt + I 들여쓰기 정렬 Ctrl + Alt + Enter 커서가 위치한 라인에 바로 위 라인에서 시작 Tab / Shift Tab 들여쓰기 추가 / 제거 Ctrl + D 커서가 위치한 라인을 복사하여 바로 밑에 라인에 붙여넣기 Ctrl + Y 커서가 위치한 라인을 삭제 Shift + Enter 커서가 위치한 라인에 바로 아래 라인에서 시작 Ctrl + Shift + U 대/소문자 변경 Ctrl + Shift + J 라인 합치기 Navigation : 이동 관련 단축키     Ctrl + N 전체 검색창 열기 (Alt + 방향키로 All, Class, File, Symbol, Actions 등 선택 가능) Alt + Right / Left 편집기(Editor) 탭 이동 ESC 윈도우 창에서 편집기(Editor) 창으로 이동 Ctrl + G 라인으로 이동 Ctrl + E 최근 열어본 파일 목록창 열기 Ctrl + Shift + E 최근 위치 목록창 열기 Ctrl + ] / [ 괄호 시작/끝으로 이동 Ctrl + F12 파일 구조창 열기 Compile and Run : 컴파일 및 실행 관련 단축키     Ctrl + F9 프로젝트 빌드(Bliud project) Shift + F10 프로젝트 실행 Shift + F9 프로젝트 디버그 VCS / Local History : 버전 관리 시스템(Version Control System) 관련 단축키     Ctrl + K Commit project to VCS Ctrl + T Update project form VCS Ctrl + Shift + K Push commits Alt + BackQuote(‘) ‘VCS’ quick popup Test Case : Test Case 관련 단축키     Ctrl + Shift + T Class에 대한 TestCase 생성 및 이동 " }, { "title": "Spring 입문 3 - 회원 관리 예제(백엔드 개발)", "url": "/posts/Spring-Study-Basic-3/", "categories": "Study, Spring", "tags": "Spring, Springoot, Study, Inflearn", "date": "2022-07-27 15:13:00 +0900", "snippet": " 인프런 김영한 님 스프링 입문 강의를 들은 후 공부한 내용입니다.비즈니스 요구사항 정리 데이터: 회원 ID, 이름 기능: 회원 등록, 조회 아직 데이터 저장소가 선정되지 않음(가상의 시나리오)일반적인 웹 어플리케이션 계층 구조 컨트롤러: 웹 MVC의 컨트롤러 역할 서비스: 핵심 비즈니스 로직 구현 리포지토리: 데이터베이스에 접근, 도메인...", "content": " 인프런 김영한 님 스프링 입문 강의를 들은 후 공부한 내용입니다.비즈니스 요구사항 정리 데이터: 회원 ID, 이름 기능: 회원 등록, 조회 아직 데이터 저장소가 선정되지 않음(가상의 시나리오)일반적인 웹 어플리케이션 계층 구조 컨트롤러: 웹 MVC의 컨트롤러 역할 서비스: 핵심 비즈니스 로직 구현 리포지토리: 데이터베이스에 접근, 도메인 객체를 DB에 저장하고 관리 도메인: 비즈니스 도메인 객체, 예) 회원, 주문, 쿠폰 등등 데이터베이스에 저장하고 관리됨클래스 의존관계 아직 DB 저장소가 선정되지 않았다는 가정이기에, interface로 구현 클래스를 변경할 수 있도록 설계 DB 저장소는 RDB, NoSQL 등등 다양한 저장소를 고민중인 상황으로 가정 개발을 진행하기 위해서 초기 개발 단계에서는 구현체로 가벼운 메모리 기반의 데이터 저장소 사용회원 도메인과 리포지토리 만들기main/java/hello.hellospring/domain/Member.java - getter와 setter 작성package hello.hellospring.domain;public class Member { private Long id; private String name; public Long getId() { return id; } public void setId(Long id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; }}main/java/hello.hellospring/repository에 MemberRepository.java 인터페이스 생성package hello.hellospring.repository;import hello.hellospring.domain.Member;import java.util.List;import java.util.Optional;public interface MemberRepository { Member save(Member member); Optional&lt;Member&gt; findById(Long id); Optional&lt;Member&gt; findByName(String name); List&lt;Member&gt; findAll();}main/java/hello.hellospring/repository에 MemoryMemberRepository.java 클래스 생성package hello.hellospring.repository;import hello.hellospring.domain.Member;import java.util.*;public class MemoryMemberRepository implements MemberRepository{ private static Map&lt;Long, Member&gt; store = new HashMap&lt;&gt;(); //실무에선 동시성 문제를 고려해야 함. private static long sequence = 0L; //실무에선 동시성 문제를 고려해야 함. @Override public Member save(Member member) { member.setId(++sequence); store.put(member.getId(), member); return member; } @Override public Optional&lt;Member&gt; findById(Long id) { return Optional.ofNullable(store.get(id)); } @Override public Optional&lt;Member&gt; findByName(String name) { return store.values().stream() .filter(member -&gt; member.getName().equals(name)) .findAny(); //람다식 } @Override public List&lt;Member&gt; findAll() { return new ArrayList&lt;&gt;(store.values()); } public void clearStore() { store.clear(); }}회원 리포지토리 테스트 케이스 작성 테스트 코드를 먼저 작성한 후 개발을 시작하면 테스트 주도 개발이라고 해서 TDD라고 함.개발한 기능을 실행해서 테스트할 때 자바의 main 메서드를 통해서 실행하거나, 웹 어플리케이션의 컨트롤러를 통해서 해당 기능을 실행한다. 이러한 방법은 준비하고 실행하는 데 오래 걸리고, 반복 실행하기 어렵고 여러 테스트를 한번에 실행하기 어렵다는 단점이 있다. 자바는 JUnit이라는 프레임워크로 테스트를 실행해서 이러한 문제를 해결한다.test/java/hello.hellospring/repository에 MemoryMemberRepositoryTest.java 클래스 생성package hello.hellospring.repository;import hello.hellospring.domain.Member;import org.junit.jupiter.api.AfterEach;import org.junit.jupiter.api.Test;import java.util.List;import static org.assertj.core.api.Assertions.assertThat;/*테스트 순서는 랜덤임. 함수가 각각 독립적이여야..따라서 테스트 하나가 끝나고 나면 데이터를 클리어해줘야 함.*/class MemoryMemberRepositoryTest { MemoryMemberRepository repository = new MemoryMemberRepository(); @AfterEach //메소드가 실행이 끝날 때마다 이 메소드가 실행됨 public void afterEach() { repository.clearStore(); } @Test public void save() { Member member = new Member(); member.setName(\"spring\"); repository.save(member); Member result = repository.findById(member.getId()).get(); //Assertions.assertEquals(member, result); //틀릴 경우 에러 assertThat(member).isEqualTo(result); //틀릴 경우 에러 } @Test public void findByName() { Member member1 = new Member(); member1.setName(\"spring1\"); repository.save(member1); Member member2 = new Member(); member2.setName(\"spring2\"); repository.save(member2); Member result = repository.findByName(\"spring1\").get(); assertThat(result).isEqualTo(member1); } @Test public void findAll() { Member member1 = new Member(); member1.setName(\"spring1\"); repository.save(member1); Member member2 = new Member(); member2.setName(\"spring2\"); repository.save(member2); List&lt;Member&gt; result = repository.findAll(); assertThat(result.size()).isEqualTo(2); }}회원 서비스 개발main/java/hello.hellospring/service에 MemberService.java 클래스 생성package hello.hellospring.service;import hello.hellospring.domain.Member;import hello.hellospring.repository.MemberRepository;import java.util.List;import java.util.Optional;//서비스는 비즈니스에 의존적으로//레포지토리는 개발적으로public class MemberService { private final MemberRepository memberRepository; public MemberService(MemberRepository memberRepository) { this.memberRepository = memberRepository; } // 회원가입 public Long join(Member member) { //같은 이름이 있는 중복 회원X validateDuplicateMember(member); memberRepository.save(member); return member.getId(); } private void validateDuplicateMember(Member member) { memberRepository.findByName(member.getName()) .ifPresent(m -&gt; { throw new IllegalStateException(\"이미 존재하는 회원입니다.\"); }); } //전체 회원 조회 public List&lt;Member&gt; findMembers() { return memberRepository.findAll(); } public Optional&lt;Member&gt; findOne(Long memberId) { return memberRepository.findById(memberId); }}회원 서비스 테스트test/java/hello.hellospring/service에 MemberService.java 클래스 생성package hello.hellospring.service;import hello.hellospring.domain.Member;import hello.hellospring.repository.MemoryMemberRepository;import org.junit.jupiter.api.AfterEach;import org.junit.jupiter.api.Assertions;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import static org.assertj.core.api.Assertions.assertThat;//테스트는 한글로 만들어도 됨class MemberServiceTest { MemberService memberService; MemoryMemberRepository memberRepository; @BeforeEach public void beforeEach() { //DI memberRepository = new MemoryMemberRepository(); memberService = new MemberService(memberRepository); } @AfterEach //메소드가 실행이 끝날 때마다 이 메소드가 실행됨 public void afterEach() { memberRepository.clearStore(); } @Test void 회원가입() { //given Member member = new Member(); member.setName(\"hello\"); //when Long saveId = memberService.join(member); //then Member findMember = memberService.findOne(saveId).get(); assertThat(member.getName()).isEqualTo(findMember.getName()); } @Test public void 중복_회원_예외() { //given Member member1 = new Member(); member1.setName(\"spring\"); Member member2 = new Member(); member2.setName(\"spring\"); //when memberService.join(member1); IllegalStateException e = Assertions.assertThrows(IllegalStateException.class, () -&gt; memberService.join(member2)); assertThat(e.getMessage()).isEqualTo(\"이미 존재하는 회원입니다.\");// try {// memberService.join(member2);// fail();// } catch (IllegalStateException e) {// assertThat(e.getMessage()).isEqualTo(\"이미 존재하는 회원입니다.\");// } //then } @Test void findMembers() { } @Test void findOne() { }}" }, { "title": "Spring 입문 2 - 정적 컨텐츠, MVC, API", "url": "/posts/Spring-Study-Basic-2/", "categories": "Study, Spring", "tags": "Spring, Springoot, Study, Inflearn", "date": "2022-07-24 21:53:00 +0900", "snippet": " 인프런 김영한 님 스프링 입문 강의를 들은 후 공부한 내용입니다. 정적 컨텐츠 서버에서 뭐 하는거 없이 파일을 웹 브라우저에 넘겨줌 MVC와 템플릿 엔진 가장 많이 하는 방식 jsp, php가 템플릿 엔진 html을 그냥 넘겨주는 것이 아닌 서버에서 프로그래밍하여 htm...", "content": " 인프런 김영한 님 스프링 입문 강의를 들은 후 공부한 내용입니다. 정적 컨텐츠 서버에서 뭐 하는거 없이 파일을 웹 브라우저에 넘겨줌 MVC와 템플릿 엔진 가장 많이 하는 방식 jsp, php가 템플릿 엔진 html을 그냥 넘겨주는 것이 아닌 서버에서 프로그래밍하여 html을 동적으로 바꾸어 보냄. 그것을 하기 위해 컨트롤러, 모델, 화면 이 세 가지를 모델 뷰 컨트롤러라 해서 MVC라 함. 둘의 차이 정적 컨텐츠는 파일을 그대로 전달. mvc와 템플릿 엔진은 서버에서 변형하여 html을 좀 바꿔서 내려주는 방식 API 네이티브 앱으로 개발을 해야할 때 json이란 데이터 구조 포맷을 사용하여 전달해줌. 서버끼리 통신할 때도 사용. 정적 컨텐츠 스프링 부트 정적 컨텐츠 기능resource/static에 hello-static.html 파일 생성&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;static content&lt;/title&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"/&gt;&lt;/head&gt;&lt;body&gt;정적 컨텐츠입니다.&lt;/body&gt;&lt;/html&gt;실행 http://localhost:8080/hello-static.html정적 컨텐츠 이미지 컨트롤러가 우선순위가 더 높음.MVC와 템플릿 엔진 MVC: Model, View, ControllerController // localhost:8080/hello-mvc/ -&gt; 오류 name 파라미터에 값이 없음 // localhost:8080/hello-mvc?name=spring! -&gt; name 파리미터에 spring! 값 넣기 @GetMapping(\"hello-mvc\") public String helloMVC(@RequestParam(name = \"name\") String name, Model model) { model.addAttribute(\"name\", name); return \"hello-temlplate\"; }Viewresource/template에 hello-template.html 생성&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;body&gt;&lt;p th:text=\"'hello' + ${name} \"&gt;hello! empty&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;실행 localhost:8080/hello-mvc?name=spring!MVC, 템플릿 엔진 이미지API@ResponseBody 문자 반환@Controllerpublic class Hellocontroller { @GetMapping(\"hello-string\") @ResponseBody // http에서 body부에 이 데이터를 직접 넣어주겠다. -&gt; html 태그 없이 public String helloString(@RequestParam(\"name\") String name) { return \"hello \" + name; }} @ResponseBody를 사용하면 뷰 리졸버(viewResolver)를 사용하지 않음 대신에 HTTP에 문자 내용을 직접 반환@ResponseBody 객체 반환@Controllerpublic class Hellocontroller { @GetMapping(\"hello-api\") //json 구조로 return -&gt; {\"name\":\"spring\"} @ResponseBody public Hello helloApi(@RequestParam(\"name\") String name) { Hello hello = new Hello(); hello.setName(name); return hello; } static class Hello { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } }}@ResponseBody 사용원리 @ResponseBody를 사용 HTTP의 BODY에 문자 내용을 직접 반환 viewResolver 대신에 HttpMessageConverter가 동작 기본 문자처리: StringHttpMessageConverter 기본 객체처리: MappingJackson2HttpMessageConverter byte 처리 등등 기타 여러 HttpMessageConverter가 기본으로 등록되어 있음. 참고: 클라이언트의 HTTP Accept 헤더와 서버의 컨트롤러 반환 타입 정보 둘을 조합해서 HttpMessageConverter가 선택된다." }, { "title": "Spring 입문 1 - 프로젝트 생성, 라이브러리, 빌드", "url": "/posts/Spring-Study-Basic-1/", "categories": "Study, Spring", "tags": "Spring, Springoot, Study, Inflearn", "date": "2022-07-22 19:46:00 +0900", "snippet": " 인프런 김영한 님 스프링 입문 강의를 들은 후 공부한 내용입니다.전에 스프링부트 프로젝트를 생성한 경험이 있어서 편하게 할 수 있었다. 인프런 김영한 님 강의를 보고 스프링 공부를 시작하게 되었다! 감기 걸려서 하루에 1강씩 들을 예정..Create a ProjectSettings Settings Info ...", "content": " 인프런 김영한 님 스프링 입문 강의를 들은 후 공부한 내용입니다.전에 스프링부트 프로젝트를 생성한 경험이 있어서 편하게 할 수 있었다. 인프런 김영한 님 강의를 보고 스프링 공부를 시작하게 되었다! 감기 걸려서 하루에 1강씩 들을 예정..Create a ProjectSettings Settings Info Name hello-spring lang Java Type Gradle Group hello Artifact hello-spring JDK 11 Java 11 Packaging Jar 요즘엔 maven 보단 gradle로 하는 추세라고 한다.artifact는 maven project에서 사용되는 개념으로만 한정하고 있다. maven project의 빌드 결과물로 나오는 개체를 artifact라고 한다. 빌드로 나오는 JAR 파일을 artifact라고 보면 된다.Group엔 보통 기업명이나 기업 도메인명을 넣는다고 한다.스프링부트 버전은 가장 최신 버전으로 한다. 사진에선 2.7.2가 가장 최신 버전이다. 스냅샷 등 괄호가 붙지 않은 것을 선택하면 된다. 스냅샷 등이 붙은 것은 베타버전. dependencies spring web thymeleaf 폴더요즘엔 메인과 테스트 폴더가 기본적으로 따로 나눠져있으며 해당 방식으로 표준화되어있다. main의 java 밑에 실제 패키지가 있으며 테스트밑엔 테스트 코드들이 들어가있다. 테스트 코드는 매우 중요하다.자바 제외한 html 파일 등은 다 resources 폴더에 넣으면 된다.실행 시켰을 때 해당 화면이 뜨면 성공!build.gradlerepositories { mavenCentral() // mavenCentral에서 디펜던시스를 다운받아라}dependencies { implementation 'org.springframework.boot:spring-boot-starter-thymeleaf' implementation 'org.springframework.boot:spring-boot-starter-web' testImplementation 'org.springframework.boot:spring-boot-starter-test'}Build 설정gradle을 통해서 빌드하면 느릴 때가 있다. gradle이 아닌 InteliJ IDEA로 바로 빌드할 수 있도록 설정을 바꿔주자.Library 살펴보기요즘 툴들은 의존 관계를 관리해준다.현업에선 System.out.println(이하 syso)보단 log를 많이 사용로그로 남겨야 심각한 에러만 따로 모아보거나 로그파일들이 관리되기 때문에 syso를 거의 쓰지 않는다고 한다. 취준생이나 아직 서버 등 관련 경험 못한 사람들은 의문이 있을 수 있다. 실무에선 log를 쓰지만 강의에선 syso를 많이 쓸 것같다고 하였다. 사람들이 저 두가지를 많이 써서 아예 포함됐다고 한다. 로그에 관해 궁금한게 있으면 slf4j랑 logback에 대해 검색해보기.정리 Gradle은 의존관계가 있는 라이브러리를 함께 다운로드 한다.스프링 부트 라이브러리 spring-boot-starter-web spring-boot-starter-tomcat: 톰캣 (웹서버) spring-webmvc: 스프링 웹 MVC spring-boot-starter-thymeleaf: 타임리프 템플릿 엔진(View) spring-boot-starter(공통): 스프링 부트 + 스프링 코어 + 로깅 spring-boot spring-core spring-boot-starter-logging logback, slf4j 테스트 라이브러리 spring-boot-starter-test junit: 테스트 프레임워크 mockito: 목 라이브러리 assertj: 테스트 코드를 좀 더 편하게 작성하게 도와주는 라이브러리 spring-test: 스프링 통합 테스트 지원 요즘엔 junit보단 junit5를 많이 쓴다고 한다.View 환경설정Welcom Page 만들기resources/static에 index.html을 만든다.&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Hello&lt;/title&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;&lt;/head&gt;&lt;body&gt;Hello&lt;a href=\"/hello\"&gt;hello&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;springboot가 지원하는 Welcome Page 기능 static/index.html을 올려두면 Welcome Page 기능을 한다. String.io에서 설명하는 Welcome Page 1.1.5. Welcome Page Spring Boot supports both static and templated welcome pages. It first looks for an index.html file in the configured static content locations. If one is not found, it then looks for an index template. If either is found, it is automatically used as the welcome page of the application. Controller웹 어플리케이션에서 첫번째 진입점이 컨트롤러이다.hello.hellospring을 마우스 우클릭하여 controller 패키지를 만든다. controller 패키지에 hellocontroller.java 파일을 만든다.코드 입력package hello.hellospring.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.GetMapping;@Controllerpublic class Hellocontroller { @GetMapping(\"hello\") public String hello(Model model) { model.addAttribute(\"data\", \"hello!!\"); return \"hello\"; }}웹 어플리케이션에서 /hello라고 들어오면 hello 함수를 호출해줄 것이다.resources/tempates에 hello.html을 만들어준다.&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;title&gt;Hello&lt;/title&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;&lt;/head&gt;&lt;body&gt;&lt;p th:text=\"'안녕하세요.' + ${data} \"&gt;안녕하세요. 손님&lt;/p&gt;&lt;!-- ${data}는 model.addAttribute(\"data\", \"hello!!\");의 data를 가리킴 따라서 hello!!로 치환됨--&gt;&lt;/body&gt;&lt;/html&gt;이렇게 뜨면 성공이다.동작 환경 컨트롤러에서 리턴 값으로 문자를 반환하면 viewResolver가 화면을 찾아서 처리한다. 스프링 부트 템플릿 엔진 기본 viewName 매핑 resource:templetes/ + {ViewName} + .html return hello를 하면 리소스에 있는 템플릿에 hello를 찾아서 렌더링을 해라라는 뜻이다. 참고: spring-boot-devtools 라이브러리를 추가하면, html 파일을 컴파일만 해주면 서버 재시작 없이 View 파일 변경이 가능하다. InteliJ 컴파일 방법: 메뉴 build -&gt; Recompile빌드하고 실행하기 cmd로 빌드강의에선 따로 cmd 창을 열어서 했는데 나는 그냥 인텔리제이 터미널에서 실행했다.맥의 경우엔 gradlew를, 윈도우의 경우엔 gradlew.bat을 빌드해주면 된다. 나는 윈도우이기에 gradle.bat 빌드방법을 적기로 하였다../gradlew.bat buildcd buildcd libs해당 코드 이후에 dir을 다시 쳐주면를 볼 수 있다. 여기서 hello-spring-0.0.1-SNAPSHOT.jar를 실행해주면 된다.java -jar hello-spring-0.0.1-SNAPSHOT.jar^C로 종료.서버 배포할 땐 저 파일만 넣어서 배포해주고 java -jar 해서 실행시키면 된다. 그러면 서버에서 스프링이 실행된다.Error./gradlew.bat build를 실행시켜서&gt; Task :compileJava FAILEDFAILURE: Build failed with an exception.* What went wrong:Execution failed for task ':compileJava'.&gt; invalid source release: 11* Try:&gt; Run with --stacktrace option to get the stack trace.&gt; Run with --info or --debug option to get more log output.&gt; Run with --scan to get full insights.* Get more help at https://help.gradle.orgBUILD FAILED in 8s1 actionable task: 1 executed해당 오류가 뜬 경우 환경변수가 jdk11로 되어있는지 확인해야한다." }, { "title": "springboot로 Rest api 만들기(1) HelloWorld", "url": "/posts/Stringboot-API-Study1/", "categories": "Study, SpringBoot", "tags": "Spring, Springoot, Study, API", "date": "2022-07-17 00:51:00 +0900", "snippet": "사용환경 공부한 내용을 되새겨볼겸 적어보았다. stack Info tool IntelliJ Community lang JAVA JDK 11 Create a Project내가 참고한 블로그에선 spring ini...", "content": "사용환경 공부한 내용을 되새겨볼겸 적어보았다. stack Info tool IntelliJ Community lang JAVA JDK 11 Create a Project내가 참고한 블로그에선 spring initializer 사이트를 이용하였는데 나는 그냥 인텔리제이를 사용하는데 익숙해져야 하기도 하고 그래서 인텔리제이 내에서 생성하였다.생성방법인텔리제이 창에서 [New Project]를 선택하면 해당 창이 뜬다. 사진에서 설정한대로 따라하면 된다. Settings Info lang Java Type Gradle JDK 11 Java 11 Packaging Jar 프로젝트 이름은 맘에드는데로 아무거나 하면 된다.[Next]를 누르면해당 창이 뜨는데 여기서 Spring Web Spring Security Spring Boot Actuator Spring Data JPA Spring Data Redis (Access + Driver) Lombok MySQL Driver H2 Database를 추가해주면 된다.다 완료됐으면 [Create] 버튼을 클릭하여 프로젝트를 생성한다.프로젝트 생성이 완료되면 [run]을 클릭하여 실행한다. 성공적으로 실행되면http://localhost:8080 링크로 접속한다.위 화면이 뜨면 성공한 것이다.Print HelloWorldPackage자바에서 패키지는 클래스와 인터페이스의 집합을 의미한다. 협업 시 서로 작업한 클래스 사이에서 발생할 수 있는 이름 충돌 문제도 패키지를 이용하면 피할 수 있다.자바에서 패키지는 물리적으로 하나의 디렉터리를 의미한다. 따라서 하나의 패키지에 속한 클래스나 인터페이스 파일은 모두 해당 패키지 이름의 디렉터리에 포함되어 있다. 이러한 패키지는 다른 패키지를 포함할 수 있으며, 이때 디렉터리의 계층 구조는 점(.)으로 구분된다.예시로package com.example.pepega.helloworld.java;package com.example2.pepega.helloworld.java;​가 있다.클래스 이름(helloworld)은 같지만 package 이름이 다르므로 다른 class로 구분된다.@SpringBootApplicationSpringBoot에서는 @SpringbootApplication (annotation이라고 한다.) 선언만으로 대부분 설정이 자동으로 이루어진다. 하단은 boot실행을 위한 Application 설정 파일이다.package com.example.pepega;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class PepegaApplication {\tpublic static void main(String[] args) {\t\tSpringApplication.run(PepegaApplication.class, args);\t}}​port 지정[resources] 우클릭 -&gt; [New] -&gt; [File] 클릭application.yml이라는 이름의 파일을 생성한 후 port를 지정한다.server: port: 80801024번 포트 이하는 특권(privileged) 포트로 지정되어 있어 root 권한으로만 사용할 수 있는 port이다.controller 패키지 생성controller 패키지를 생성한다.[com.example.프로젝트_이름] 우클릭 -&gt; [new] -&gt; [Package]를 클릭한다. 나는 이미 생성한 뒤라서 사진에 controller가 뜨는 것을 볼 수 있다.controller 패키지에 ApiPracticeController.java를 생성한다. 저 이름이 맘에들지 않는다면 다른 원하는 이름으로 지어도 상관없다.혹시 자바파일을 생성하고 난 후package com.example.프로젝트_이름.controller;패키지 이름이 위와 같지 않다면 수정해준다. 수정은 해당 파일 우클릭 -&gt; [Refactor] -&gt; [Rename]이다.대충 이런 식으로 되어있어야 한다.controller 작성package com.example.api_practice.controller;import lombok.Getter;import lombok.Setter;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.ResponseBody;/*@ControllerSpring에 해당 Class가 Controller 임을 알려주기 위해 class명 상단에 @Controller를 붙여준다. */@Controllerpublic class ApiPracticeController { /* @GetMapping(\"RequestURI\") GetMapping을 붙이면 해당 주소의 Resource를 이용하기 위해서 Get method(get, post) 로 호출해야 한다는 뜻이다. */ /* @ResponseBody 결과를 응답에 그대로 출력한다는 의미다. @ResponseBody를 지정하지 않으면 return에 지정된 \"helloworld\" 이름으로 된 파일을 프로젝트 경로에서 찾아 화면에 출력한다. */ //화면에 helloworld 출력 @GetMapping(value = \"/helloworld/string\") @ResponseBody public String helloworldString() { return \"helloworld\"; } //화면에 {message:\"helloworld\"} 출력 @GetMapping(value = \"/helloworld/json\") @ResponseBody public Hello helloworldJson() { Hello hello = new Hello(); hello.message = \"helloworld\"; return hello; } //화면에 helloworld.ftl의 내용이 출력 @GetMapping(value = \"/helloworld/page\") public String helloworld() { return \"helloworld\"; } /* @Getter @Setter 선언되어있는 변수를 알아서 Getter, Setter(lombok)가 되도록 지정해준다. */ @Setter @Getter public static class Hello { private String message; }} @Controller Spring에 해당 Class가 Controller 임을 알려주기 위해 class명 상단에 @Controller를 붙여준다. @GetMapping(“RequestURI”) GetMapping을 붙이면 해당 주소의 Resource를 이용하기 위해서 Get method(get, post) 로 호출해야 한다는 뜻이다. http://localhost:8080/helloworld/json 웹 브라우저에 위 주소창을 실행하면 Get방식으로 호출된다. /helloworld/ json을 Mapping하고 있는 메서드( public Hello helloworldJson() )가 실행된다. @ResponseBody 결과를 응답에 그대로 출력한다는 의미다. @ResponseBody를 지정하지 않으면 return에 지정된 “helloworld” 이름으로 된 파일을 프로젝트 경로에서 찾아 화면에 출력한다. @Getter @Setter 선언되어있는 변수를 알아서 Getter, Setter(lombok)가 되도록 지정해준다. Create ftl Fileresource 파일 아래 templates 우클릭 -&gt; [New] -&gt; [File]을 클릭하여helloworld.ftl을 생성한다.ftl 파일 내에HelloWorld작성application.yml 에 하단 내용을 추가한다.spring: freemarker: template-loader-path: classpath:/templates/ suffix: .ftlbuild.gradle 에 하단 내용을 추가한다.implementation 'org.springframework.boot:spring-boot-starter-freemarker'​실행결과 User name: user Passworld: 밑의 콘솔 확인아래는 로그인 후 뜨는 화면이다.로그인이 됐으면 각각 주소를 실행한다.http://localhost:8080/helloworld/stringhttp://localhost:8080/helloworld/jsonhttp://localhost:8080/helloworld/page실행화면" }, { "title": "21th Developer Meetup - 오픈서치 기반 오라클 클라우드의 Search Service 알아보기 웨비나 후기", "url": "/posts/Oracle-OpenSearch-Webinar/", "categories": "Webinar, Oracle", "tags": "Webinar, Seminar, Oracle, OpenSearch", "date": "2022-07-14 02:16:00 +0900", "snippet": "깃허브 Dev-Event repo를 보던 중 오라클에서 웨비나를 개최한다는 것을 보아 신청하게 되었다. 신청할 때만 해도 강연일까지 꽤 시간이 남아있었던 걸로 기억하는데 코앞으로 다가와 좀 망설여졌다. 아직 나는 개발지식이 부족하다고 느꼈기때문에 내가 이걸 들어서 이해를 할 수 있을까 고민이 많았다. 그 덕에 밤을 설친듯 싶다.웨비나는 오라클 클라우드...", "content": "깃허브 Dev-Event repo를 보던 중 오라클에서 웨비나를 개최한다는 것을 보아 신청하게 되었다. 신청할 때만 해도 강연일까지 꽤 시간이 남아있었던 걸로 기억하는데 코앞으로 다가와 좀 망설여졌다. 아직 나는 개발지식이 부족하다고 느꼈기때문에 내가 이걸 들어서 이해를 할 수 있을까 고민이 많았다. 그 덕에 밤을 설친듯 싶다.웨비나는 오라클 클라우드의 Search Service를 소개하고 설명해주는 방식으로 진행되었다. 강의 시간은 17:00~18:00으로 1시간 강의였다. 아래는 ppt에 적혀있는 내용을 조금 적어놓은 것이다.OCI 관리형 검색 엔진 서비스OCI + OpenSearchOpenSearch 기반 Oracle Cloud Infrastructure(OCI) 검색 서비스는 완전 관리형 서비스로 정형/비정형 데이터 검색 기능을 제공합니다. 서비스 패치, 업데이트, 업그레이드, 백업 및 크기 조정을 자동화 지원하며, 가동 중단이 발생하지 않습니다. 서비스 사용자는 대용량 데이터의 빠른 저장, 검색 및 분석하고 거의 실시간으로 결과를 확인할 수 있습니다.OpenSearch 프로젝트OpenSearch는 Apache 2.0 라이선스 Elasticsearch 7.10.2 및 Kibana 7.10.2에서 파생된 커뮤니티 중심의 오픈 소스 검색 및 분석 프로젝트입니다.OCI Search 서비스는 완전 관리형 클라우드 네이티브 서비스입니다.완전 관리형 제공 기능: 자동화 패치 및 보안 업데이트, 업그레이드, 클러스터 크기 변경, 스케쥴 백업, HA데이터 안전성: FIPS 준수 서비스오픈서치 기반 오라클 클라우드의 Search Service 주요 특징과 차별성 완전 관리형 자동화된 클러스터 생성 오브젝트 스토리지에 예약 백업 운영체제 레벨 패치 인프라 문제 발생에 대한 모니터링과 재배포 비교 불가 유연성 OCI Flex shape을 통해서 높은 CPU/메모리 설정 자유도 지원 다운 타임 없이 클러스터 크기 조정 보안 &amp; 규제 준수 세분화된 엑세스 제어 및 권한 부여를 위해 OCI IAM과 통합 모든 저장 데이터와 이동 데이터 암호화 FIPS 보안 준수 업계 최고 가격 경쟁력 / 성능 AWS, Azure, GCP 대비 ~35-50% 저렴 첫 2개 노드는 서비스 비용에서 제외 강력한 인사이트 지원 대시보드는 데이터를 시각화하는 수십가지 방법을 제공 OpenSearch Dashboard API를 활용하여 타사 앱에서 시각화 및 분석 확인 온프레미스, 클라우드 또는 둘 다에 있는 데이터 수집 자동화된 HA 노드를 3개 이상 배포하면 OCI는 여러 AD(Availability Domain) 또는 폴트 도메인(Fault Domain)에 걸쳐 노드를 자동 프로비져닝. FAQ 데이터 규모에 대한 제약 : 0.3PB까지 제약 - &gt; 추가 확장 SR Document / Index 크기 제약 : 서비스에 대한 제약은 없고 OS와 HW에 따른 제약은 잇음 OpenSearch Intefration : 가능 근데 LogStash, FluentD, Beats 사용할 경우 따로 설정해줘야? 향후에 OCI Service Connect Hub 이용하기 때문에 별도 소프트웨어 필요 x OpenSearch 백업/ Snapshot 저장 위치 : OCI Object Storage 마이크레이션 방법을 제공하나요? 옵션 1 : 시계열 데이터 이관 현재 하고 있는 것과 똑같은 방식으로 데이터를 수집 수집이 정상 수행 확인 이전 수집을 중단하고 관리형 서비스 유지 옵션 2 ELK와 OpenSearch 클러스터의 스냅샷 로딩 CSP 호스팅: 스냅샷을 오브젝트 스토리지에 저장 온프레미스 호스팅: 스냅샷의 크기를 처리할 수 있는 위치에 배치 스냅샷을 OCI Object Storage 이전 My Oracle Support(MOS)에 스냅샷을 OCI OpenSearch 서비스에 로딩 요청 Q&amp;A 타 클라우드 서비스에서 오픈서치 대시보드에 오류로 접근이 안됐는데 OCI는 따로 설정해야하는지? 기본적으로 접근 안됨. 지금은 보안적인 측면에 따라 안됨 private 존임. OCI에 카프카 서비스로 들어오나요? 이미 OCI 스트리밍 서비스로 들어와있음 오픈서치는 관련 서비스로 생각하면 됨. 오픈서치와 OCI 검색할 때 고려해야할 사항 모델을 만드는 것에 대해서 인덱스를 어떻게 해야할지 고려해야함 미리 제약사항을 얘기하자면 한글은 아직 안됨 지금 시점으로 2주안에 배포될 것. " }, { "title": "Google I/O Extended 2022 Daejeon 후기", "url": "/posts/GOOGLE-IOE-in-Daejeon/", "categories": "Conference, Google", "tags": "Conference, Google, Daejeon, IOE", "date": "2022-07-01 22:34:00 +0900", "snippet": "Google IO Extended 2022 Daejeon 해당 행사는 6월 30일 20시부터 22시까지 진행하는 행사였다.나는 이 행사를 운좋게 발견했다. 7월에 갈 수 있는 컨퍼런스 · 인턴쉽이 있나 찾아보다가 발견하게 되었다. 발견한건 부산이 먼저였고, 시간은 오후 8시 7분 쯤이었는데 부산은 오프라인, 대전은 온라인이라서 급하게 들어가게 되었다...", "content": "Google IO Extended 2022 Daejeon 해당 행사는 6월 30일 20시부터 22시까지 진행하는 행사였다.나는 이 행사를 운좋게 발견했다. 7월에 갈 수 있는 컨퍼런스 · 인턴쉽이 있나 찾아보다가 발견하게 되었다. 발견한건 부산이 먼저였고, 시간은 오후 8시 7분 쯤이었는데 부산은 오프라인, 대전은 온라인이라서 급하게 들어가게 되었다. 다행히도 두 행사 모두 8시부터 시작이라 난 7분 늦은 시각에 들어가게 되었다. 처음엔 디스코드로 진행 중이었는데 안타깝게도 인원이 꽉 차 내가 들어갈 수 없는 상태였다. 그러다 35분쯤 못들어오는 인원을 고려해 구글미트로 옮기겠다는 채팅을 보았고, 서둘러 구글 미트로 접속하였다. 앞의 약 40분은 놓쳤지만 그래도 구글에서 진행하는 것이고, 첫 컨퍼런스라 만족스러웠다. 이 컨퍼런스를 듣고 더 공부를 열심히 해야겠다는 의지와 의욕이 생겼다.행사 화면아래는 구글 I/O에서 설명한 해당 행사에 대한 설명이다.What is Extended io?About this eventI/O connects developers from around the world for thoughtful discussions, hands-on learning with Google experts, and a first look at Google’s latest developer products.What is Google IO event?Google I/O (or simply I/O) is an annual developer conference held by Google in Mountain View, California. “I/O” stands for Input/Output, as well as the slogan “Innovation in the Open”. The event’s format is similar to Google Developer Day. Google I/O. Date(s)What do you expect out of the Google IO event?During the event, the company is expected to reveal Android 13 and two new smart products. Read for details. Google’s annual tech conference, the Google I/O 2022 is about to be held this month. As announced by the company, the event will take place on May 11 and May 12 in California.세션※ 순서와 내용은 추후 변경될 수 있습니다. 신형섭: State of CSS: CSS 안부 묻기 컨테이너 쿼리, 서브그리드 등 CSS 최신 기술과 동향에 대해 알아 봅니다. 박다솜: 개인을 위한 접근성 설계 머터리얼 디자인의 접근성 개선을 위해 어떤 전략을 통해 구성됐는지 확인합니다. 박수지: Core Web Vitals: 구현 그 너머의 세계 더 나은 사용자 경험을 위한 Core Web Vitals 와 google I/O 2022 에서 소개된 내용을 살펴봅니다 안재영: Platform faster with Cloud Code: 생산성 향상을 위한 원포인트툴 Cloud Code 서비스의 규모가 커지면서 여러 툴, 여러 시스템을 돌아다니면서 생산성이 떨어지기 마련입니다. CloudCode에서는 이를 어떻게 해결했는지 함께 알아봅니다 이상훈: Flutter 101: 웹 개발자가 플러터로 앱 개발하기 웹 개발자의 시선에서 플러터 초기 구현부터 최근 3.0 업데이트 내용까지 알아봅니다. 김인철: Firebase with Web: 장님의 파이어베이스 다리(웹) 만져보기 웹개발자가 알아두면 좋을 파이어베이스의 기능과 업데이트된 기능을 알아봅니다. 해당 이벤트를 통해 기술의 최신 동향과 여러 업데이트 된 기능들을 알 수 있었다. 안타깝게도 늦게 들어오는 바람에 가장 듣고싶었던 Core Web Vitals: 구현 그 너머의 세계를 듣지 못했다. 다행히 친절하시게도 ppt를 올려주셔서 ppt는 갖고있는 상태이다. css 업데이트된 내용이 꽤 흥미로웠던 것으로 기억한다.이 행사 이벤트로 추첨 5명을 뽑아 한정판 굿즈를 선물하는게 있었는데 무척이나 갖고싶다. 그래도 큰 기대는 안하고 있다.+) 이벤트에 당첨됐다. 해커톤 준비를 하던 도중 메일함을 확인하니 이벤트에 당첨됐다고 주소를 보내달라고 메일이 와있었다. 정말 기대도 안하고 있었는데.. 이 글도 아직 google search console 오류로 구글에 뜨지 않은 상태인데.. 다행히 내가 쓴 후기와 피드백이 꽤 맘에 들었나보다." }, { "title": "Jekyll chirpy 테마 적용", "url": "/posts/Jekyll-chirpy-theme/", "categories": "Post, Jekyll", "tags": "Jekyll, Blog, Theme, Error", "date": "2022-06-30 17:06:00 +0900", "snippet": "이제껏 지킬 테마를 많이 바꿔왔지만 이렇게 최악인 테마는 처음이다.이쁘고 깔끔하지만 os가 windows인 경우 chirpy 테마는 최악이다.나는 fork도 시도해보고 zip파일도 다운받아서 해봤지만 어느 하나 실행되는 것이 없었다. 둘 다 빌드 오류와 에러 문구만 주구장창 봤다.구글에 올라온 블로그란 블로그는 다 시도해봤는데 실패했다. 나는 이 테마...", "content": "이제껏 지킬 테마를 많이 바꿔왔지만 이렇게 최악인 테마는 처음이다.이쁘고 깔끔하지만 os가 windows인 경우 chirpy 테마는 최악이다.나는 fork도 시도해보고 zip파일도 다운받아서 해봤지만 어느 하나 실행되는 것이 없었다. 둘 다 빌드 오류와 에러 문구만 주구장창 봤다.구글에 올라온 블로그란 블로그는 다 시도해봤는데 실패했다. 나는 이 테마 하나 적용하겠다고 ruby도 다운받고 linux ubuntu도 다운받았다.결국 chirpy starter를 사용해서 적용에 성공하였다.bash tools/init.sh해당 명령어를 사용하여 초기화를 해줘야 했는데Error: Commit unstaged files first, and then run this tool againt.가 뜨면서 작동을 안하는 것이다.나는 마지막 방법으로 chirpy starter를 사용하였고 마침내 성공했다.다들 나처럼 쓸데없는 데에 힘빼지 말고 대충 3번 시도해서 안돼면 chirpy starter를 한번 시도해보길 바란다.chirpy starter를 사용하면 커스터마이징할 때 오류가 많다는 (해결할 수 있는) 글을 읽고 고민중이라면 starter를 사용하기 바란다. 나는 chirpy starter를 사용하고 왼쪽의 사이드바와 글자 색, 아바타, favicon을 손쉽게 바꿨다. 딱히 대대적인 공사를 할게 아니라 그냥 이미지나 색만 바꾸고 싶다면, 커스터마이징의 범위가 좁다면. 그냥 chirpy starter를 사용하는게 해당 테마를 이용하여 블로그를 만들 수 있는 가장 빠른 지름길이다. 커스터마이징은 대충 구글에 올라온 블로그 2~3개 참고하면 쉽게 가능하다.1. chirpy starter를 이용해 레포지토리 시작이걸 시작하기 전 os가 windows일 경우 ruby를 설치하길 바란다.먼저 제작자의 설명을 읽어보자. 설명 읽으러 가기Option 1의 Chirpy Starter를 클릭하여 레포지토리를 만들고, 로컬 저장소에 클론한다.최근에 파일이 바뀐건지bash tools/init.sh를 치지 않아도 괜찮은 것 같다. 이 명령어는 넘어가주자. 폴더에 .travis.yml이 있는지 없는지를 보고 결정하면 될 것 같다. 나는 없었다.2. _config.yml 수정 링크를 참고하여 수정해주기 바란다. (url을 꼭 작성해야 한다.) 개인적으로 다른 블로그보다 설명이 더 잘 되어있다고 생각돼서 가져왔다.3. Rubyos가 windows인 사람만 ruby를 사용하고 아닌 사람은 그냥 cmd창을 사용하면 될 것이다. ruby를 작동시켜 블로그의 로컬 저장소로 이동해준다.cd C:\\Users\\Nadud\\Documents\\GitHub\\NadudAn.github.io그리고 번들을 설치한다.$ bundle4. 깃허브에 올려준다.git bash를 이용하여$ git add *$ git commit -m \"initialize\"$ git push -u origin masterERROR이후 나는 오류가 하나 더 났었는데Your bundle only supports platforms [\"x64-unknown\"] but your local platform is x86_64-linux. Add the current platform to the lockfile with `bundle lock --add-platform x86_64-linux` and try again.이 에러는 스택 오버플로우를 보고 해결하였다.ruby로 로컬 저장소를 들어가$ bundle lock --add-platform ruby$ bundle lock --add-platform x86_64-linux를 쳐준 뒤 다시 커밋 &amp; 푸쉬해준다.나는 커스터마이징은 쉽게 할 수 있었기에 따로 적지는 않겠다. 구글에 검색하여 블로그 몇 개 들어가서 따라하다보면 해결될 것이다. 나는 2개정도 참고한 것 같다." }, { "title": "Twitter Project - Github Actions를 이용 학식 자동 트윗 봇", "url": "/posts/Twitter-Bot/", "categories": "Projects, Twitter", "tags": "Portfolio, Projects, Twitter, Api, TwitterDeveloper", "date": "2022-04-06 15:00:00 +0900", "snippet": "excerpttweeting University Cafeteria’s Lunch Menus in twitter for myself. And learning how to crawl the data with python, and how to use a api.Info 프로젝트명 공주대(천안) 학식봇 제작기간 2022.04.03 ...", "content": "excerpttweeting University Cafeteria’s Lunch Menus in twitter for myself. And learning how to crawl the data with python, and how to use a api.Info 프로젝트명 공주대(천안) 학식봇 제작기간 2022.04.03 ~ 2022.04.06 (4일) 참여인원 1명 개발환경 Python, Twitter API, Tweepy, Selenium, Github Action 목적 API 및 크롤링 익히기 자동봇 만들어보기 구현내용 파이썬을 이용한 크롤링으로 학교 홈페이지 내 데이터 가져오기 트위터 API와 Tweepy를 사용해 트윗 깃허브 액션을 이용해 매일 UTC 기준 01:00(한국시간 오전 10시)마다 학식 메뉴 트윗 기타 개인 프로젝트 결과물 @KNU_Lunch_Menu [Twitter Project] 공주대 학식 자동트윗봇먼저 이 프로젝트를 처음으로 트위터 api를 사용했다. 꽤 복잡하고 어려웠지만 하다보니 할만했던 것 같다. 밤새 코딩하면서 재미를 느낄 수 있었다.Twitter Developer트위터 봇을 만드려면 트위터 디벨로퍼의 승인을 받은 트위터 계정이 필요하다. 승인 받는 방법은 구글링을 통해 따로 알아보길 바란다.트위터 디벨로퍼 승인받은 당시의 소감Twitter api &amp; Tweepy봇을 만들기 위해선 4개의 키가 필요하다. Api Key Api Key Secret Access Token Access Token Secret나는 이번 프로젝트에서 Tweepy, Selenium, Chrome Driver를 사용하였다. 그런데, 자동봇을 만들기 위해 파이썬으로 코딩하여 트윗을 작성하면 알겠지만 개발자 계정에 트윗이 된다.매번 봇을 만들 때마다 승인을 받는건 여간 귀찮은 일이 아니다. 따라서 트위터 디벨로퍼에서 발급받은저 4개의 키를 이용해 자동봇 계정의 Access Token과 Access Token Secret을 만들 것이다.해당 내용에 대해선 블로그에 자세히 적어놓았다.Github Environment내 깃허브 코드를 보면 알겠지만 Api key나 Access token이 드러나있지 않고 Environment를 이용하여 환경에서 변수를 받아왔다.해당 4개의 키를 그대로 드러내기엔 계정의 중요한 정보라 거부감이 든다.따라서 나는 Secret에 인증키들을 등록하는 방법을 사용하였다.workflow나는 workflow를 윈도우 버전으로 작성하였다. 매일 UTC 00:00 기준으로 트윗이 올라가게끔 작성하였으며 트윗할 때마다 크롬 드라이버를 다운받아 unzip한 뒤 사용하도록 만들었다.프로젝트의 더 자세한 코드는 https://github.com/NadudAn/KNU_Cafeteria_Menu에서 볼 수 있다.# This workflow will install Python dependencies, run tests and lint with a variety of Python versions# For more information see: https://help.github.com/actions/language-and-framework-guides/using-python-with-github-actionsname: Python packageon: schedule: - cron: '0 0 * * *' push: branches: [ main ] pull_request: branches: [ main ]jobs: build: runs-on: windows-latest #strategy: #fail-fast: false #matrix: #python-version: [\"3.8\", \"3.9\", \"3.10\"] steps: - uses: actions/checkout@v3 - name: Set up Python 3.10 uses: actions/setup-python@v3 with: python-version: 3.10 - name: Install dependencies run: | python -m pip install --upgrade pip pip install -r requirements.txt #if [ -f requirements.txt ]; then pip install -r requirements.txt; fi - name: Download chromedriver run: | (New-Object System.Net.WebClient).DownloadFile('https://chromedriver.storage.googleapis.com/100.0.4896.60/chromedriver_win32.zip', 'chromedriver.zip') Expand-Archive .\\chromedriver.zip . #tar -zxvf [chromedriver.zip] -C [chromedriver] - name: Tweets run: | python3 \"main.py\" env: TWITTER_API_KEY: $ TWITTER_API_SECRET: $ TWITTER_ACCESS_TOKEN: $ TWITTER_ACCESS_TOKEN_SECRET: $동작 화면" }, { "title": "Twitter API - 개발자 계정 외 자동봇의 액세스 토큰 발급(7자리 PIN이 뜨지 않는 경우)", "url": "/posts/TwitterApi-AccessToken-Error/", "categories": "Post", "tags": "Portfolio, Projects, Twitter, Api, TwitterDeveloper, Error, AccessToken", "date": "2022-04-04 15:00:00 +0900", "snippet": "excerptTwitter Api Access Token Error 이 글은 제 네이버 블로그에서 옮겨온 글입니다.이런 글을 쓰지 않으려 했는데 제 이후로 트위터 api를 사용하시는 분들이 저와 같은 경우를 겪을 경우를 대비하여 적습니다.먼저 개발자 계정이 아닌 다른 계정의 Access Token과 Access Token Secret을 발급받는 소스...", "content": "excerptTwitter Api Access Token Error 이 글은 제 네이버 블로그에서 옮겨온 글입니다.이런 글을 쓰지 않으려 했는데 제 이후로 트위터 api를 사용하시는 분들이 저와 같은 경우를 겪을 경우를 대비하여 적습니다.먼저 개발자 계정이 아닌 다른 계정의 Access Token과 Access Token Secret을 발급받는 소스코드 전문입니다. 일단 자바와 파이썬을 가지고 왔습니다.Access Token과 Access Token Secret을 발급받는 소스코드//JAVAimport java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import twitter4j.Twitter;import twitter4j.TwitterException;import twitter4j.TwitterFactory;import twitter4j.auth.AccessToken;import twitter4j.auth.RequestToken;public class HttpSourceCall { static AccessToken accessToken = null; static String accessSecret = \"\"; static Twitter twitter; public static void main(String[] args) { RequestToken requestToken = null; AccessToken finalAccessToken = null; twitter = TwitterFactory.getSingleton(); twitter.setOAuthConsumer(\"YOUR_API_KEY\", \"YOUR_API_KEY_SECRET\"); //토큰 requestToken = null; try { requestToken = twitter.getOAuthRequestToken(); } catch (TwitterException e) { e.printStackTrace(); } BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); System.out.println(requestToken.getAuthenticationURL());\t\t System.out.println(\"Enter the PIN and hit enter after you granted access\"); String pin = \"\";\t\t try { pin = br.readLine(); } catch(IOException e1) { e1.printStackTrace(); }\t\t try { if(pin.length() &gt; 0) accessToken = twitter.getOAuthAccessToken(requestToken, pin); else accessToken = twitter.getOAuthAccessToken(requestToken); String key1 = accessToken.getToken(); String key2 = accessToken.getTokenSecret(); System.out.println(\"accessToken: \" + accessToken); System.out.println(\"getToken: \" + key1); System.out.println(\"getTokenSecret: \" + key2); } catch(TwitterException te) { if(401 == te.getStatusCode()) { System.out.println(\"unable to get the access token\"); System.out.println(te); } else te.printStackTrace(); } }}#Pythonimport tweepyimport webbrowserimport timeconsumer_key = \"YOUR_API_KEY\"consumer_secret = \"YOUR_API_KEY_SECRET\"#개발자 계정 신청 후 받은 본인의 컨슈머 키와 컨슈머 시크릿 키 입력callback_uri = 'oob'auth = tweepy.OAuthHandler(consumer_key, consumer_secret, callback_uri)redirect_url = auth.get_authorization_url()print(redirect_url)#앱 적용할 계정으로 전환 후 출력되는 URL 클릭webbrowser.open(redirect_url)user_pint_input = input(\"핀번호 입력 : \") #oauth_verifier=&lt;핀 번호&gt; 영어 섞여잇어도 ㄱㅊ은듯?user_pint_input#인증 URL에 들어가서 수락 한 뒤 뜨는 PIN 번호 입력auth.get_access_token(user_pint_input)print(\"액세스 토큰 : \", auth.access_token, \"\\n\", \"액세스 시크릿 토큰 : \", auth.access_token_secret)api = tweepy.API(auth)me = api.me()print(me.screen_name)#인증 완료된 계정 아이디자바와 파이썬 코드 둘 다 같은 방법으로 작동합니다.실행시키면 링크를 얻고 (개발자 계정이 아닌) 봇계정으로 로그인 후 링크로 들어가 앱 인증을 합니다.여기까진 괜찮은데 간혹 오류가 나거나 다른 블로그에선 알려주지 못한 상황이 발생합니다.401 ERROR의 경우트위터 디벨로퍼 내 앱의 설정을 바꿀 경우 api 키와 액세스 토큰 등을 새로 발급받아야 합니다.7자리 PIN 번호가 뜨지 않는 경우두 번째로 코드 실행해서 링크를 얻고, 봇 계정으로 들어가 앱 인증까지 마쳤으나 7자리 PIN 번호를 받지 못한 경우입니다.이 경우에 대해선 인터넷에 잘 나와있지 않더라구요. 저만 PIN 번호가 안뜨는지?블로그를 따라 잘 진행했음에도 불구하고이 화면이 뜨지 않는 분들을 위한 설명입니다.일단 파이썬으로 어떻게 봇 계정의 액세스 토큰을 발급받는지 설명드리겠습니다. 자바 또한 같은 방법으로 따라하시면 됩니다.1. 먼저 봇 계정으로 트위터 로그인을 한 후 위의 파이썬 코드를 실행, 링크를 받습니다.저는 M7로 시작하는 링크를 얻었네요.2. 해당 링크를 들어가 앱 인증을 해줍니다.앱 인증을 해주면 PIN 번호가 뜨지 않고 트위터 디벨로퍼 내에 설정해둔 callback url로 넘어갑니다. 저는 twitter.com으로 해둬서 그냥 타임라인이 떴어요.근데 그 위 링크를 보시면주황색으로 가려둔 거 보이시나요? 저 가려진 부분을 복사해야합니다.3. oauth_verifier=의 뒷 부분을 복사해 콘솔에 핀 번호로 입력 후 토큰을 얻습니다.저 부분을 복사해서 핀 번호로 입력하면 액세스 토큰과 액세스 시크릿 토큰이 나옵니다.해당 토큰들이 자동봇의 액세스 및 시크릿 토큰입니다.참고로 해당 토큰을 한 번 발급 받으면 다시 발급 안받아도 되고 계속 쓸 수 있습니다.아무도 해당 내용에 대해 글을 써주지 않더라구요 저만 PIN 번호가 안뜨나 싶을정도로..ㅠㅠ제 서치가 미흡한걸수도.. 5시간동안 해매며 찾은 내용입니다. 즐거운 개발되세요:)" }, { "title": "My financiall", "url": "/posts/my-financialledger/", "categories": "Projects, App", "tags": "Portfolio, Projects, App, Primitive", "date": "2021-02-26 15:00:00 +0900", "snippet": "excerptKNU Primitive club Android Project. My own account book, A account book application that helps users understand their spending and consumption patterns more easily.Info 프로젝트명 나만의 가계...", "content": "excerptKNU Primitive club Android Project. My own account book, A account book application that helps users understand their spending and consumption patterns more easily.Info 프로젝트명 나만의 가계부 제작기간 2021.01.25 ~ 2021.02.26 (33일) 참여인원 5명 개발환경 JAVA, Android Studio, Room DB 나의 역할 입출금 내역 기록 기능의 화면 레이아웃과 데이터베이스로의 데이터 전송 및 불러오기 목적 1. 동아리 내 신입생들의 앱 개발 학습효과 극대화. 2. 앱 구현 및 데이터베이스에 대한 이해 3. 안드로이드 스튜디오 학습 구현내용 1. 사용자가 입력한 데이터를 데이터베이스로 전송 2. 데이터베이스에서 데이터 가져오기 3. 일/월별 지출액 비교 4. 목표 달성 현황 5. 목표 금액과 지출유형, 은행 설정 6. 장르별 사용 내역 그래프로 띄우기 If you click, move to GitHub." } ]
